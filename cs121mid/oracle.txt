-- [Problem 18]


This second step takes so long since t2.a is a foreign key onto t1.a. Additionally, an index was created on t1.a. Thus when we DELTE FROM t1 WHERE a IN (list of values to remove), our database will delete the corresponding tuple from t1 and then go through all of t2 to find the corresponding tuple and delete that as well. Additionally, since the first step already deleted all the rows from t2 containing values of a that appear in t1, then overtime a row is removed in t1, the database has to go through all of the (2 billion - 40) rows of t2 to double check that those have been removed as well. The copies of the row in the index must be removed as well. Thus, this creates a horrendously slow performance of removing the small number of rows. To fix this, we can simply run these two steps in reverse order as well as create an index on t2. To begin, we could begin by writing CREATE INDEX idx_a ON t2(a). This will create a faster look up time. We can then DELETE FROM t1 WHERE a IN (list of values to remove) first, so our query will be able to move to the next a that is in the list of values more quickly since those values wouldnâ€™t have already been removed in t2. Finally, we would run the first statement and delete the remaining tuples in t2 where t2.a = t1.a.